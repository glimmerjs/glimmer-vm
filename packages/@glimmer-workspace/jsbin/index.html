<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Minimal Glimmer Rendering</title>
    <script type="module">
      import {
        runtimeOptions,
        NewTreeBuilder,
        renderComponent,
        renderSync,
        on,
      } from "@glimmer/runtime";
      import { EvaluationContextImpl, templateFactory } from "@glimmer/opcode-compiler";
      import { artifacts, RuntimeOpImpl } from "@glimmer/program";
      import { setComponentTemplate, setInternalComponentManager } from "@glimmer/manager";
      import { precompile, precompileJSON } from "@glimmer/compiler";
      import { trackedData } from "@glimmer/validator";
      import { preprocess, getTemplateLocals } from "@glimmer/syntax";
      import boilerplateComponentManager from "./boilerplate-example-component-manager";

      const scheduledDestructors = [];
      const scheduledFinalizers = [];

      function flush(queue) {
        for (const fn of queue) fn();
        queue.length = 0;
      }

      function createEnvDelegate(isInteractive) {
        return {
          isInteractive: true,
          enableDebugTooling: false,
          onTransactionCommit() {
            flush(scheduledDestructors);
            flush(scheduledFinalizers);
          },
        };
      }

      class Counter {
        #data = trackedData({ count: 0 });

        get count() {
          return this.#data["count"];
        }
        increment = () => this.#data["count"]++;

        static {
          setInternalComponentManager(boilerplateComponentManager, this);
          setComponentTemplate(
            /* Custom Compile Template because Glimmer Standalone is very unergonomic */
            compileTemplate(
              `<p>You have clicked the button {{this.count}} times.</p>

              <button {{on "click" this.increment}}>Click</button>`,
              { scope: { on } },
            ),
            this,
          );
        }
      }

      /**
       *
       * Copied from limber/ember-repl
       *
       * The reason why we can't use precompile directly is because of this:
       * https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/compiler/lib/compiler.ts#L132
       *
       * Support for dynamically compiling templates in strict mode doesn't seem to be fully their yet.
       * That JSON.stringify (and the lines after) prevent us from easily setting the scope function,
       * which means that *everything* is undefined.
       */
      function compileTemplate(source, { moduleName, scope = {} }) {
        const localScope = { ...scope };
        const locals = getTemplateLocals(source);

        const options = {
          strictMode: true,
          moduleName,
          locals,
          isProduction: false,
          meta: { moduleName },
        };

        // Copied from @glimmer/compiler/lib/compiler#precompile
        const [block, usedLocals] = precompileJSON(source, options);

        const usedScope = usedLocals.map((key) => {
          const value = localScope[key];

          if (!value) {
            throw new Error(
              `Attempt to use ${key} in compiled hbs, but it was not available in scope. ` +
                `Available scope includes: ${Object.keys(localScope)}`,
            );
          }

          return value;
        });

        const blockJSON = JSON.stringify(block);
        const templateJSONObject = {
          id: moduleName,
          block: blockJSON,
          moduleName: moduleName ?? "(dynamically compiled component)",
          scope: () => usedScope,
          isStrictMode: true,
        };

        const factory = templateFactory(templateJSONObject);

        return factory;
      }

      function render() {
        const element = document.body;
        const sharedArtifacts = artifacts();
        const envDelegate = createEnvDelegate();
        const components = new Map();
        const helpers = new Map();
        const modifiers = new Map();

        const resolver = {
          lookupHelper: (name) => helpers.get(name) ?? null,
          lookupModifier: (name) => modifiers.get(name) ?? null,
          lookupComponent: (name) => components.get(name) ?? null,

          lookupBuiltInHelper: () => null,
          lookupBuiltInModifier: () => null,
        };

        const runtime = runtimeOptions({ document }, envDelegate, sharedArtifacts, resolver);

        const context = new EvaluationContextImpl(
          sharedArtifacts,
          (heap) => new RuntimeOpImpl(heap),
          runtime,
        );

        const env = context.env;
        const cursor = { element, nextSibling: null };
        const treeBuilder = NewTreeBuilder.forInitialRender(env, cursor);

        renderSync(env, renderComponent(context, treeBuilder, {}, Counter, {}));
      }

      render();
    </script>
  </head>
  <body></body>
</html>
