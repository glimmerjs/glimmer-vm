// @ts-check

import { buildEnum, buildMetas, normalizeAll, strip } from '@glimmer/debug';
import { readFileSync, writeFileSync } from 'node:fs';
import { parse as parseToml } from 'toml';
import { resolveConfig, format as formatPrettier } from 'prettier';

// const fs = require('node:fs');
// const toml = require('toml');
// const prettier = require('prettier');
// const { normalizeAll, buildEnum, buildMetas, strip } = require('@glimmer/debug');

/**
 * @param {string} file
 */
function parse(file: string) {
  const opcodes = readFileSync(file, { encoding: 'utf8' });

  const raw = parseToml(opcodes) as Parameters<typeof normalizeAll>[0];
  return normalizeAll(raw);
}

const parsed = parse('./packages/@glimmer/vm/lib/opcodes.toml');

const machine = buildEnum('MachineOp', parsed.machine, 0, 15);
const syscall = buildEnum('Op', parsed.syscall, 16);

write(
  './packages/@glimmer/vm/lib/opcodes.ts',
  `import { Op, MachineOp } from '@glimmer/interfaces';\n\n` +
    machine.predicate +
    '\n' +
    syscall.predicate
);

write(
  './packages/@glimmer/interfaces/lib/vm-opcodes.d.ts',
  machine.enumString + '\n\n' + syscall.enumString
);

let debugMetadata = strip`
  import { MachineOp, Op, Option } from '@glimmer/interfaces';
  import { NormalizedMetadata } from './metadata';

  function fillNulls<T>(count: number): T[] {
    let arr = new Array(count);

    for (let i = 0; i < count; i++) {
      arr[i] = null;
    }

    return arr;
  }

  export function opcodeMetadata(op: MachineOp | Op, isMachine: 0 | 1): Option<NormalizedMetadata> {
    let value = isMachine ? MACHINE_METADATA[op] : METADATA[op];

    return value || null;
  }

  const METADATA: Option<NormalizedMetadata>[] = fillNulls(Op.Size);
  const MACHINE_METADATA: Option<NormalizedMetadata>[] = fillNulls(MachineOp.Size);
`;

debugMetadata += buildMetas('MACHINE_METADATA', parsed.machine);
debugMetadata += buildMetas('METADATA', parsed.syscall);

write('./packages/@glimmer/debug/lib/opcode-metadata.ts', debugMetadata);

function write(file: string, contents: string) {
  console.log(`Generating ${file}`);

  format(
    file,
    strip`
/* This file is generated by build/debug.js */

${contents}
  `
  );
}

/*
  Formats the string in accordance with our prettier rules to avoid
  test failures.
*/
function format(file: string, contents: string) {
  const options = resolveConfig.sync(file);
  const newContents = formatPrettier(contents, Object.assign({}, options, { filepath: file }));

  if (newContents !== contents) {
    writeFileSync(file, newContents, { encoding: 'utf8' });
  }
}
