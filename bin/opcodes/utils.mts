import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, relative, resolve } from 'node:path';
import chalk from 'chalk';
import { spawnSync } from 'node:child_process';

const MISSING_INDEX = -1;
const REMOVE = 1;

interface OpcodesJson {
  outputs: {
    code: string;
    interface: string;
    debug: string;
  };
  machine: string[];
  syscall: string[];
}

interface Paths {
  config: string;
  root: string;
  packages: string;
}

interface Options {
  verbose: boolean;
  dryRun: boolean;
  help: boolean;
}

type Target = keyof OpcodesJson['outputs'];

export class Emitter {
  static argv(config: string, here: ImportMeta) {
    const __dirname = new URL('.', here.url).pathname;
    const configPath = resolve(__dirname, config);
    const json = JSON.parse(readFileSync(configPath, 'utf-8'));

    const root = dirname(__dirname);
    const packages = resolve(root, 'packages');
    const ARGV = [...process.argv.slice(2)];

    const verbose = extractFlag(ARGV, '--verbose') || extractFlag(ARGV, '-v');
    const dryRun = extractFlag(ARGV, '--dry-run') || extractFlag(ARGV, '-d');
    const help = extractFlag(ARGV, '--help') || extractFlag(ARGV, '-h');

    return new Emitter(json, { root, packages, config: configPath }, ARGV, {
      verbose,
      dryRun,
      help,
    });
  }

  readonly #json: OpcodesJson;
  readonly #paths: Paths;
  readonly #args: string[];
  readonly #options: Options;

  constructor(json: OpcodesJson, paths: Paths, args: string[], options: Options) {
    this.#json = json;
    this.#paths = paths;
    this.#args = args;
    this.#options = options;
  }

  get type(): string | undefined {
    return this.#args[0];
  }

  get target(): string | undefined {
    return this.#args[1];
  }

  get options(): Options {
    return this.#options;
  }

  get opcodes(): { machine: string[]; system: string[] } {
    return {
      machine: this.#json.machine,
      system: this.#json.syscall,
    };
  }

  writeTarget(name: Target): (code: string[]) => void {
    return (code) => {
      this.write(code, this.#resolvePath(name));
    };
  }

  newline(): void {
    this.human('');
  }

  #resolvePath(name: Target) {
    switch (this.target) {
      case '-':
        return '-';
      case undefined:
        return resolve(this.#paths.packages, this.#json.outputs[name]);
      default:
        return resolve(this.#paths.root, this.target);
    }
  }

  write(code: string[], path: string) {
    const outputString = [
      `// This code was generated by $root/bin/opcodes.mts.`,
      `// Do not change it manually.`,
      '',
      ...code,
    ].join('\n');

    const dir = dirname(path);

    if (!existsSync(dir)) {
      this.human(`Directory ${chalk.cyan(dir)} does not exist.`);
      process.exit(1);
    }

    const result = spawnSync(`pnpm`, ['prettier', '--parser', 'typescript'], {
      cwd: this.#paths.root,
      input: outputString,
      stdio: ['pipe', 'pipe', 'inherit'],
      encoding: 'utf-8',
    });

    const { stdout: formatted } = result;

    if (formatted === null) {
      this.human(
        chalk.red.inverse('ERROR'),
        'running',
        `pnpm prettier --parser typescript`,
        'at',
        chalk.cyan(this.#paths.root)
      );
      this.newline();
      this.human(chalk.yellow.inverse('STDIN'));
      this.logOutput(outputString);
      this.newline();
      process.exit(1);
    }

    if (this.#options.dryRun) {
      this.human(
        chalk.cyan.inverse('[DRY RUN]'),
        chalk.grey(`Writing ${chalk.cyan(relative(this.#paths.root, path))}...`)
      );
    }

    if (path === '-') {
      this.emit(formatted);
      return;
    } else if (this.#options.dryRun) {
      this.logOutput(formatted);
      this.newline();
      return;
    }

    this.human(chalk.grey(`Writing ${chalk.cyan(path)}...`));
    writeFileSync(path, formatted);

    if (this.#options.verbose) {
      const written = readFileSync(path, 'utf-8');
      this.human('');
      this.human(chalk.bgGrey('Output:'));
      this.logOutput(written);
      this.newline();
    }
  }

  logOutput(output: string) {
    this.human('');
    for (const line of output.split('\n')) {
      this.human(`${chalk.grey('|')}  ${chalk.green.dim(line)}`);
    }
  }

  get imports(): { code: string; interface: string; debug: string } {
    return {
      code: this.#extractImport('code'),
      interface: this.#extractImport('interface'),
      debug: this.#extractImport('debug'),
    };
  }

  #extractImport(type: Target): string {
    const match = /^@glimmer\/[^/]*/.exec(this.#json.outputs[type])?.[0];

    if (!match) {
      this.human(`Invalid output.${type} in opcodes.json: ${chalk.cyan(this.#paths.config)}`);
      this.human(chalk.yellow(`Output files must be nested in '@glimmer/*' packages`));
      process.exit(1);
    }

    return match;
  }

  /**
   * Anything intended to be piped should be sent to `stdout`.
   */
  emit(...args: unknown[]) {
    console.log(...args);
  }

  /**
   * Anything that isn't intended to be piped should be sent to `stderr` (really
   * should be called `stdlog` imo).
   */
  human(...args: unknown[]) {
    console.error(...args);
  }
}

function extractFlag(argv: string[], name: string): boolean {
  const index = argv.indexOf(name);

  if (index === MISSING_INDEX) {
    return false;
  }

  argv.splice(index, REMOVE);
  return true;
}
