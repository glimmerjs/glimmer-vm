<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Glimmer Test Suite</title>
  <link rel="stylesheet" href="assets/qunit.css">
</head>
<body>
  <script>
    if (typeof console === "undefined") {
      console = {
        log: function(){},
        warn: function(){},
        error: function(){},
        group: function(){},
        groupEnd: function(){},
      }
    }
  </script>

  <div id="qunit"></div>
  <div id="qunit-fixture"></div>
  <script src="assets/qunit.js"></script>
  <script src="/testem.js"></script>
  <script src="assets/loader.js"></script>
  <script src="assets/vendor.js"></script>
  <script src="assets/glimmer-vm.js"></script>
  <script src="assets/tests.js"></script>
  <script>
    function getPackagesToTest() {
      if (QUnit.urlParams.packages) {
        return QUnit.urlParams.packages.split(',');
      }
    }

    // Recursively merge all the dependencies for this configuration of
    // packages to ensure that we only inject each dependency once.
    // Testing dependencies are only injected for the packages being tested.
    var packagesToTest = getPackagesToTest();
  </script>

  <script>
    QUnit.config.autostart = false;
    QUnit.config.urlConfig.push({
      id: "notslint",
      label: "Disable TSLint",
      tooltip: "Do not include any TSLint tests"
    });
    QUnit.config.urlConfig.push({
      id: "glimmer_logging",
      label: "Enable Glimmer Logging",
      tooltip: "Enable Glimmer Logging"
    });


    var testMatch;
    var notslint = QUnit.urlParams.notslint;

    if (packagesToTest) {
      testMatch = new RegExp("^(" + packagesToTest.join("|") + ").*-test$");
    } else {
      testMatch = /-test$/;
    }

    Object.keys(requireModule.entries).forEach(function(entry) {
      if (entry.match(testMatch)) {
        if (notslint && entry.match(/\.lint-test$/)) return;
        requireModule(entry)
      };
    });

    // Here we've got some trickiness for working with wasm. There's a few
    // things we need to account for with this:
    //
    // * First, the wasm can take some time to compile. We can't run any tests
    //   until it's done, so we use the `booted` promise to actually kick off
    //   the QUnit tests.
    //
    // * Next, some wasm-managed heap items aren't actually freed in JS. For
    //   example the heap (`WasmHeap`) is never freed in JS. Normal glimmer
    //   programs never need to free it anyway, and otherwise the object here
    //   is managed by the JS GC so we don't know when it's deallocated.
    //   Unfortunately for tests though we create enough programs that it blows
    //   the 2GB memory limit for wasm if we don't free anything, so we have
    //   a workaround here which frees all instances of `WasmHeap` after each
    //   test has completed. Nothing like making our own arena!
    //
    // * Finally we want to ensure that there aren't any memory leaks in wasm,
    //   so here we register a callback before/after each test to verify
    //   that the amount of memory in use is the same before and after each
    //   test.

    var numAllocated = 0;
    var lowLevel = require('@glimmer/low-level');
    var freeAllWasmPrograms = require('@glimmer/program').freeAllWasmPrograms;

    QUnit.testStart(function() {
      numAllocated = lowLevel.num_allocated();
    });
    QUnit.testDone(function(details) {
      freeAllWasmPrograms();
      if (lowLevel.num_allocated() != numAllocated)
        throw new Error("the test " + details.name + " didn't free all wasm memory")
    });
    lowLevel.booted.then(() => {
      QUnit.start();
    });
  </script>
</body>
</html>
